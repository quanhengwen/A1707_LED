/***************************************************************************************************
*                    (c) Copyright 2008-2018  Syncretize technologies co.,ltd.
*										All Rights Reserved
*
*\File          canbus_middle.c
*\Description   
*\Note          
*\Log           2018.08.29    Ver 1.0    Job
*               创建文件。
***************************************************************************************************/
#include "canbus_middle.h"
#include "iap_if.h"
#include "flash_if.h"

RingBufType CAN_BUF500={0};
u8 canbuf500[2048]={0};
u8 otacanbuf500[2048]={0};

static u16 OTA_Version = 0;//版本
static u32 OTA_TotalSize = 0;//bin长度
static u32 OTA_SubSize = 0;//分包固定长
static u32 OTA_CRC32 = 0;//校验
static u16 OTA_Frame_Num = 0;//升级包序号
//OTA协议标志
static u8 OTA_UpdateFlag = 0;// 0 未升级，1 开始，2 传输中，3 传输完成
u32 can500_buf_recv(u8* buf, u32 len, bool state)
{
    return ReadDataFromBuf(&CAN_BUF500, buf, len, state);
}
u32 can500_buf_del(u32 len)
{
    return DelDataFromBuf(&CAN_BUF500, len);  
}
bool can500_buf_clear(void)
{
    return ClearDateFromBuf(&CAN_BUF500);
}

extern void system_reset(void);
/***************************************************************************************************
*\Function      OTA_Start_ACK_Construct
*\Description   OTA开始ACK构建
*\Parameter     buf
*\Parameter     len
*\Return        u32
*\Note
*\Log           2018.01.19    Ver 1.0    Job
*               创建函数。
***************************************************************************************************/
u32 CAN_OTA_Start_ACK_Construct(u8* buf, u32 len)
{
	u32 data_len = 10;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = CAN_OTA_Send_Start;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID
	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}

/***************************************************************************************************
*\Function      OTA_Update_ACK_Construct
*\Description   传输过程中ACK
*\Parameter     buf
*\Parameter     len
*\Return        u32
*\Note
*\Log           2018.01.19    Ver 1.0    Job
*               创建函数。
***************************************************************************************************/
u32 CAN_OTA_Update_ACK_Construct(u8* buf, u32 len, u8 state_code)
{
	u32 data_len = 13;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = CAN_OTA_Send_Update;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID

	buf[i++] = (u8)OTA_Frame_Num;
	buf[i++] = (u8)(OTA_Frame_Num >> 8);
	buf[i++] = state_code;

	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}
/***************************************************************************************************
*\Function      OTA_End_ACK_Construct
*\Description
*\Parameter     buf
*\Parameter     len
*\Return        u32
*\Note
*\Log           2018.01.19    Ver 1.0    Job
*               创建函数。
***************************************************************************************************/
u32 CAN_OTA_End_ACK_Construct(u8* buf, u32 len)
{
	u32 data_len = 10;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = CAN_OTA_Send_End;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID
	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}

/***************START***********设备管理/搜索/自检baron****************************************/

/***************************************************************************************************
*\Function      CAN_Paramset_Read_Construct
*\Description   设备参数的读取
*\Parameter     buf
*\Parameter     id_buf  目标id
*\Parameter     len
*\Return        u32
*\Note
*\Log           2019.03.07    Ver 1.0    baron
*               创建函数。
***************************************************************************************************/
__weak u32 CAN_Paramset_Read_Construct(u8* buf , u32 len)//需要每人根据自己的项目组包
{
	u32 data_len = 18;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = FUC_PARAMSET_READ;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID

	buf[i++] = 0x00;// param
	buf[i++] = 0x00;// 
	buf[i++] = 0x00;// 
	buf[i++] = 0x00;// 
	buf[i++] = 0x00;// 
	buf[i++] = 0x00;// 
	buf[i++] = 0x00;// 
	buf[i++] = 0x00;// 
	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}

/***************************************************************************************************
*\Function      CAN_AUTOMATIC_CHECK_ACK_Construct
*\Description   自动检测发送回复
*\Parameter     buf
*\Parameter     id_buf  目标id
*\Parameter     len
*\Return        u32
*\Note
*\Log           2019.03.08    Ver 1.0    baron
*               创建函数。
***************************************************************************************************/
__weak u32 CAN_Automatic_Check_Construct(u8* buf, u32 len)//根据不同的设备进行组包
{
	u32 data_len = 24;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = FUC_DEVICE_SEARCH;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID

	buf[i++] = 0x00;     //具体需检测参数单独添加
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}
/***************************************************************************************************
*\Function      CAN_Paramset_Receive_Analyse
*\Description   数据解析
*\Parameter     buf
*\Parameter     len
*\Return        u32
*\Note
*\Log           2019.03.08    Ver 1.0    baron
*               创建函数。
***************************************************************************************************/
__weak void CAN_Paramset_Receive_Analyse(u8* buf)//需要根据自己的协议解析函数
{
	u32 data_len = ((buf[2] << 8) | buf[1]);
	u32 i = 0;

}

/***************************************************************************************************
*\Function      CAN_Paramset_write_Construct
*\Description   设备参数写入回复
*\Parameter     buf
*\Parameter     id_buf  目标id
*\Parameter     len
*\Return        u32
*\Note
*\Log           2019.03.07    Ver 1.0    baron
*               创建函数。
***************************************************************************************************/
u32 CAN_Paramset_Write_Construct(u8* buf, u32 len)
{
	u32 data_len = 10;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = FUC_PARAMSET_WRITE;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID

	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}
/***************************************************************************************************
*\Function      CAN_PARAMSET_SAVE_ACK_Construct
*\Description   参数写入flash回复
*\Parameter     buf
*\Parameter     id_buf  目标id
*\Parameter     len
*\Return        u32
*\Note
*\Log           2019.03.07    Ver 1.0    baron
*               创建函数。
***************************************************************************************************/
u32 CAN_Paramset_Save_Construct(u8* buf, u32 len)
{
	u32 data_len = 10;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = FUC_PARAMSET_SAVE;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID

	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}
/***************************************************************************************************
*\Function      CAN_DEVICE_RESTART_ACK_Construct
*\Description   重启设备回复
*\Parameter     buf
*\Parameter     id_buf  目标id
*\Parameter     len
*\Return        u32
*\Note
*\Log           2019.03.07    Ver 1.0    baron
*               创建函数。
***************************************************************************************************/
u32 CAN_Device_Restart_Construct(u8* buf, u32 len)
{
	u32 data_len = 10;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = FUC_DEVICE_RESTART;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID

	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}
/***************************************************************************************************
*\Function      CAN_PARAMSET_DEFAULT_ACK_Construct
*\Description   恢复默认回复
*\Parameter     buf
*\Parameter     id_buf  目标id
*\Parameter     len
*\Return        u32
*\Note
*\Log           2019.03.07    Ver 1.0    baron
*               创建函数。
***************************************************************************************************/
u32 CAN_Paramset_Default_Construct(u8* buf, u32 len)
{
	u32 data_len = 10;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = FUC_PARAMSET_DEFAULT;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID

	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}
/***************************************************************************************************
*\Function      CAN_DEVICE_SEARCH_ACK_Construct
*\Description   设备搜索回复
*\Parameter     buf
*\Parameter     id_buf  目标id
*\Parameter     len
*\Return        u32
*\Note
*\Log           2019.03.08    Ver 1.0    baron
*               创建函数。
***************************************************************************************************/
u32 CAN_Device_Search_Construct(u8* buf, u32 len)
{
	u32 data_len = 32;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = FUC_DEVICE_SEARCH;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID

	buf[i++] = iap_param.ChipUniqueID[0] & 0xFF;     //UUID0
	buf[i++] = (iap_param.ChipUniqueID[0] >> 8) & 0xFF;
	buf[i++] = iap_param.ChipUniqueID[1] & 0xFF;
	buf[i++] = (iap_param.ChipUniqueID[1] >> 8) & 0xFF;
	buf[i++] = iap_param.ChipUniqueID[2] & 0xFF;
	buf[i++] = (iap_param.ChipUniqueID[2] >> 8) & 0xFF;
	buf[i++] = iap_param.ChipUniqueID[3] & 0xFF;
	buf[i++] = (iap_param.ChipUniqueID[3] >> 8) & 0xFF;
	buf[i++] = iap_param.ChipUniqueID[4] & 0xFF;
	buf[i++] = (iap_param.ChipUniqueID[4] >> 8) & 0xFF;
	buf[i++] = iap_param.ChipUniqueID[5] & 0xFF;
	buf[i++] = (iap_param.ChipUniqueID[5] >> 8) & 0xFF;//UUID11
	buf[i++] = iap_param.swversion & 0xFF;             //iap版本低
	buf[i++] = (iap_param.swversion >> 8) & 0xFF;        //iap版本高
	buf[i++] = iap_param.hwversion;                  //硬件版本
	buf[i++] = iap_param.IAP_flag;                 //iap标志位
	buf[i++] = 0x00;//app版本低
	buf[i++] = 0x00;//app版本高
	buf[i++] = (u8)iap_param.ID;;//网关ID低
	buf[i++] = (u8)(iap_param.ID >> 8);//网关ID高
	buf[i++] = 0x00;
	buf[i++] = 0x00;
	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}
/***************************************************************************************************
*\Function      CAN_DEVICE_PARAMSET_SEARCH_ACK_Construct
*\Description   设备搜索参数设置回复
*\Parameter     buf
*\Parameter     id_buf  目标id
*\Parameter     len
*\Return        u32
*\Note
*\Log           2019.03.08    Ver 1.0    baron
*               创建函数。
***************************************************************************************************/
u32 CAN_Device_Paramset_Search_Construct(u8* buf, u32 len)
{
	u32 data_len = 10;
	u32 i = 0;

	if (len < data_len)
	{
		return 0;
	}

	buf[i++] = CAN_COMM_PROTOCOL_HEAD;
	buf[i++] = (u8)(data_len);
	buf[i++] = (u8)((data_len) >> 8);
	buf[i++] = FUC_DEVICE_PARAMSET_SEARCH;
	buf[i++] = (u8)iap_param.remoteID;//remoteID
	buf[i++] = (u8)(iap_param.remoteID >> 8);//remoteID
	buf[i++] = (u8)iap_param.ID;//ID
	buf[i++] = (u8)(iap_param.ID >> 8);//ID

	buf[i++] = Get_Sum8(buf + 1, data_len - 3);
	buf[i++] = CAN_COMM_PROTOCOL_TAIL;

	return i;
}


//设备搜索 设置设备ID
void CAN_Device_Paramset_Search_SetID(u8* buf)
{
	u32 i=0;
	int check_sum=0;
	uint16_t RecvUUID[6];//uuid
	uint16_t RecvID;//设备需要调整的id
	RecvID=((buf[27] << 8) | buf[26]);
	RecvUUID[0]=((buf[9] << 8) | buf[8]);
	RecvUUID[1]=((buf[11] << 8) | buf[10]);
	RecvUUID[2]=((buf[13] << 8) | buf[12]);
	RecvUUID[3]=((buf[15] << 8) | buf[14]);
	RecvUUID[4]=((buf[17] << 8) | buf[16]);
	RecvUUID[5]=((buf[19] << 8) | buf[18]);
	for(i=0;i<6;i++)
	{
		if(RecvUUID[i]==iap_param.ChipUniqueID[i])
		{
			check_sum+=1;
		}
		else
		{
			check_sum+=0;
		}
	}
	
	if(check_sum==6)
	{//uuid校验通过 写入id
		iap_param.ID=RecvID;
	}
	else
	{//uuid校验不通过
		
	}
	
}


/***************END****************************************************************************/

/***************************************************************************************************
*\Function      can500_protocol_anylise
*\Description   
*\Parameter     comm
*\Parameter     buf
*\Parameter     len
*\Return        del_info_type
*\Note          
*\Log           2018.08.30    Ver 1.0    Job               
				创建函数。
***************************************************************************************************/
static can_del_info_type can500_protocol_anylise( u8* buf, u32 len)
{
    can_del_info_type info = {can_anylise_waiting, 0};
    u32 i = 0;
    u32 data_len = 0;
    u16 dev_ID = 0;

    u32 updata_len = 0;//升级包小包长度
    u32 send_len = 0;
    u8 send_buf[100];
    CRC32_CTX CRC32;
	iap_updata_param_type iap_updata_param_data;
	uint32_t addr_appcopy = FLASH_START_ADDR + Get_FlashSize() * 1024 - FLASH_APP_COPY_ADDR*FLASH_PAGE_SIZE;//FLASH_APP_COPY_ADDR;
    if (len >= CAN_COMM_PROTOCOL_MIN_LEN)
    {
        /*开始解析*/
        i = 0;
        while (1)
        {
            /*同步头、尾不正确或者校验和不正确*/
            if ((buf[i] !=  CAN_COMM_PROTOCOL_HEAD))
            {
                for (i += 1; i < len; i++)
                {
                    if (buf[i] == CAN_COMM_PROTOCOL_HEAD)
                    {
                        break;
                    }
                }
                if (len - i >=  CAN_COMM_PROTOCOL_MIN_LEN)
                {
                    continue;
                }
                else
                {
                    info.state = can_anylise_reject;
                    info.del_len = i;
                    return info;
                }      
            }
            else
            {
                /*查找数据包长度*/
                data_len = buf[i + 2];
                data_len = (data_len << 8) + buf[i + 1];
                //长度合法判断 目前长度允许8-1200
                if (data_len > CAN_COMM_PROTOCOL_MAX_LEN || data_len < CAN_COMM_PROTOCOL_MIN_LEN)
                {
                    i++;
                    continue;
                }
                /*如果接收数据长度小于帧构成长度 继续等待*/
                if (len - i < data_len)
                {
                    /*i == 0表示正确的帧头前面没有错误数据 返回等待,否则删除错误的数据*/
                    if (i == 0)
                    {
                        info.state = can_anylise_waiting;
                        info.del_len = 0;
                    }
                    else
                    {
                        info.state = can_anylise_reject;
                        info.del_len = i;
                    }
                    return info;
                }
                /*检测帧尾,帧尾符合规则 就认为这是一个完整的数据帧*/
                if (buf[i + data_len - 1] == CAN_COMM_PROTOCOL_TAIL && 
                    buf[i + data_len - 2] == Get_Sum8(buf + i + 1, data_len - 3))
                {
                    break;
                }
                else//帧尾校验不符合 删除一个字节 继续查找
                {
                    i += 1;
                    continue;
                }
            }
        }
        //验证通过，进行协议处理
        info.state = can_anylise_accept;//先预设为接收
        //先筛选出ID 备用
        dev_ID = buf[i + 5];
        dev_ID = (dev_ID << 8) | buf[i + 4];
		
        iap_param.remoteID = buf[i + 7];
        iap_param.remoteID = (dev_ID << 8) | buf[i + 6];
		
		if ((iap_param.ID == dev_ID) || (iap_param.ID == 0xFFFF))
		{
			switch (buf[i + 3])
			{
			case CAN_OTA_Recv_Start:
				//解析版本 包长 分包长 总校验 此处开始张波调整协议增加一位6 信道
				OTA_UpdateFlag = 1;
				OTA_Version = buf[i + 9];
				OTA_Version = (OTA_Version << 8) | buf[i + 8];

				OTA_TotalSize = ArrayU8ToU32(buf + i + 12);

				OTA_SubSize = ArrayU8ToU16(buf + i + 16);

				OTA_CRC32 = ArrayU8ToU32(buf + i + 18);

				printf("\r\nCAN_OTA_Start...\r\n");

				memcpy(&iap_updata_param_data, buf + i + 10, sizeof(iap_updata_param_data));
				//			iap_updata_param_data.Version = OTA_Version;

				printf("Bin[%d], Sub[%d], CRC32[%08X]\r\n", OTA_TotalSize, OTA_SubSize, OTA_CRC32);

				//存储bin长度+crc32
				Flash_Storage_Header((uint8_t *)&iap_updata_param_data);
				//擦除待写区域
				Flash_Erase_Page(addr_appcopy, OTA_TotalSize);

				//回复ACK
				send_len = CAN_OTA_Start_ACK_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}
				printf("Update:");
				break;
			case CAN_OTA_Recv_Update:
				OTA_UpdateFlag = 2;
				//升级包 更新
				OTA_Frame_Num = ArrayU8ToU16(buf + i + 8);
				printf("%d,", OTA_Frame_Num + 1);
				if (data_len > 10 && OTA_Frame_Num * OTA_SubSize < OTA_BIN_MAX_SIZE)
				{
					//updata_len应该是4的倍数
					updata_len = data_len - 12;
					Flash_Write(addr_appcopy + (OTA_Frame_Num)* OTA_SubSize, buf + i + 10, updata_len);
					//ack
					send_len = CAN_OTA_Update_ACK_Construct(send_buf, sizeof(send_buf), 0);
					if (send_len)
					{
						canbus_middle_send(&CAN, 0x500, send_buf, send_len);
					}
				}
				else
				{
					send_len = CAN_OTA_Update_ACK_Construct(send_buf, sizeof(send_buf), 1);
					if (send_len)
					{
						canbus_middle_send(&CAN, 0x500, send_buf, send_len);
					}
				}

				break;
			case CAN_OTA_Recv_End:
				HAL_Delay(10);
				//升级完成 重启更新
				OTA_UpdateFlag = 3;
				//回复ACK
				printf("\r\nCAN_OTA_End\r\n");
				send_len = CAN_OTA_End_ACK_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}
				UpdateAppMode();
				printf("IAP_FLAG: 0x%X \n\r", (uint16_t)ReadIAPMode());
				HAL_Delay(100);
				NVIC_SystemReset();
				break;
				/*********************START**********设备管理/搜索/自检baron***************************************/
			case FUC_PARAMSET_READ:            //设备参数读取			
				send_len = CAN_Paramset_Read_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}			
				break;
			case FUC_PARAMSET_WRITE:           //设备参数写入
				//具体参数的写入单独设置
				CAN_Paramset_Receive_Analyse(&buf[i]); //将数据存入receive_buf
				send_len = CAN_Paramset_Write_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}		
				break;
			case FUC_PARAMSET_SAVE:            //参数写入flash			
				//具体参数写入flash单独设置
				iap_param_save();
				send_len = CAN_Paramset_Save_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}			
				break;
			case FUC_DEVICE_RESTART:           //重启设备 			
				send_len = CAN_Device_Restart_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}
				HAL_Delay(10);
				system_reset();					
				break;
			case FUC_PARAMSET_DEFAULT:         //恢复默认参数							
				send_len = CAN_Paramset_Default_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}
				iap_param_default();
			break;
			case FUC_DEVICE_SEARCH:            //设备搜索		
				send_len = CAN_Device_Search_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					
					if(iap_param.ID == 0xFFFF)
					{
						//无等待
					}
					else
					{
						HAL_Delay(((iap_param.ID >> 8) & 0xFF) * 10 + (iap_param.ID & 0xFF) * 2);
					}
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}	
				break;
			case FUC_DEVICE_PARAMSET_SEARCH:   //设备搜索参数设置			
				//设备搜索过程仅可以修改id
				CAN_Device_Paramset_Search_SetID(&buf[i]); //将数据存入receive_buf
				send_len = CAN_Device_Paramset_Search_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}		
			break;
			case FUC_AUTOMATIC_CHECK:          //自动检测		
				send_len = CAN_Automatic_Check_Construct(send_buf, sizeof(send_buf));
				if (send_len)
				{
					canbus_middle_send(&CAN, 0x500, send_buf, send_len);
				}			
				break;
			/*********************END*******************************************************************/
			default:
				printf("the cmd[%d] is no support!\n", buf[i + 3]);
				break;
			}
		}
		
       

        info.del_len = data_len + i; 
        return info;
    }
    else
    {
        return info;
    } 
}
/***************************************************************************************************
*\Function      canbus_middle_send
*\Description   CAN数据发送
*\Parameter     can
*\Parameter     ID
*\Parameter     buf
*\Parameter     len
*\Return        u32
*\Note          
*\Log           2018.08.30    Ver 1.0    Job               
				创建函数。
***************************************************************************************************/
u32 canbus_middle_send(CANBus_type* can, u32 stdID, u8* buf, u32 len)
{
    CANBusTx_type tx;
    u32 i = 0;
    u32 num = 0;
    u32 len_left = 0;

    if (!can || len == 0 || !buf)
    {
        return 0;
    }

    num = len / 8;
    len_left = len % 8;

    tx.CANTxHead.StdId = stdID;
    tx.CANTxHead.IDE = CAN_ID_STD;
    tx.CANTxHead.RTR = CAN_RTR_DATA;

    //每次发送8字节
    for (i = 0; i < num; i++)
    {
        tx.CANTxHead.DLC = 8;
        memcpy(tx.Data, buf + i * 8, 8);
        if (!stm32_CAN_send(can, &tx))
        {
            return i * 8;
        }
        if (i % 10 == 0)
        {
            HAL_Delay(10);
        }
    }

    //发送多余的字节
    if (len_left)
    {
        tx.CANTxHead.DLC = len_left;
        memcpy(tx.Data, buf + num * 8, len_left);
        if (!stm32_CAN_send(can, &tx))
        {
            return num * 8;
        }
    }

    return len;
}



#include "usdl_buf.h"
//can 数据解析相关初始化
void CAN_middle_init(void)
{
	RingBufInit(&CAN_BUF500,canbuf500, 1024);
    stm32_CAN_clear(&CAN);
}

static int CANOTAWaitTicks;
void CAN_OTA_Periodic_Handle(void)
{
    u32 len = 0;
	CANBusRx_type rx;
    u32 delay = 0;
	can_del_info_type info = {can_anylise_waiting, 0};
    int tick_diff;
	
	if (stm32_CAN_recv(&CAN, &rx))
	{
		
		delay++;
		if (delay % 10 == 0)
		{
			HAL_Delay(10);
			delay = 0;
		}
		
		if (rx.CANRxHead.IDE != CAN_ID_STD || rx.CANRxHead.RTR != CAN_RTR_DATA)
		{
//                continue;
		}
		switch (rx.CANRxHead.StdId)
		{
		case 0x500:
			AddDataToBuf(&CAN_BUF500, rx.Data, rx.CANRxHead.DLC);
			{
				u32  i = 0;
//				printf("LEN:%d\n", rx.CANRxHead.DLC);
//				for(i = 0; i< rx.CANRxHead.DLC;i++)
//				{
//					printf("%02X ", rx.Data[i]);
//				}
//				printf("\r\n");
			}


			break;
		default:
			printf("StdID[0x%03X] is no support!\n", rx.CANRxHead.StdId);
			break;
		}
	}
	else
	{
		delay = 0;
		HAL_Delay(10);
	}
	
	len = ReadDataFromBuf(&CAN_BUF500, otacanbuf500, sizeof(otacanbuf500), FALSE);
	if (len == 0)
	{
		CANOTAWaitTicks = HAL_GetTick();		
		return;
	}
//	printf("LEN:%d\r\n", len);
	info = can500_protocol_anylise(otacanbuf500, len);
	if (info.state != can_anylise_waiting)
	{
		//删除
		DelDataFromBuf(&CAN_BUF500, info.del_len);
		CANOTAWaitTicks = HAL_GetTick();
	}
	else
	{
		tick_diff = HAL_GetTick() - CANOTAWaitTicks;
		if (Abs(tick_diff) > 10*100)//超过5S解析不成功，则清空缓冲区数据（或者保守一点，删除一个字节，但这样会解析比较慢）
		{
			stm32_CAN_clear(&CAN);
			CANOTAWaitTicks = HAL_GetTick();
		} 
	}
	
}
















